= MisterMusik - Developer Guide
:site-section: DevelopGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-F11-4/main

By: `Team CS2113T-F11-4`      Since: `Aug 2019`      Licence: `MIT`


== Setting up


== Design
=== Overall Architecture
There are three main components in the overall architecture of the application.

`Duke` class: contains the `main()` class of the application.
* Upon startup: a Welcome Message is printed (see section under Ui) data is loaded from the memory storage to the system.
* Upon exit (when the user enters 'bye'): a Goodbye Message is printed (see section under Ui).

`Events` Package: contains classes pertaining to the events.

`UserElements` Package: contains classes pertaining to I/O and the interaction between user and system.

=== UI component
=== Model component
=== Storage component
=== Common classes

== Implementation
This section describes some noteworthy details on how certain features are implemented.

=== Calendar Table
The calendar table is generated from the `EventList`. It prints on the screen a table of calendar of 7 days
starting from a specified day, including the events within this time period. +

==== How it is implemented
Given below is how a calendar table is generated and printed.

Step 1. User enters `calendar` to start the initialization process of a calendar table with today as the starting day.

Step 2. The program checks the date of the given start day to generate a list of 7 days, starting from given day.
It also gets the day of the 7 days (e.g. Monday, Tuesday, etc). This sets the dates info of the table.
====
E.g. Example of a day and dates list

image::DGCalendarTableDaysList.png[width = 75%]
====

Step 3. The program find all events in the `EventList` that is within the 7 days,
and store them correspondingly into 7 queues, representing the 7 days. This is for further printing.
====
E.g. Example of an event list of 7 days

image::DGCalendarTableExample.png[width = 75%]
====

Step 4. The program now have all the information of these 7 days and is then able to print the calendar table.

. It initiates an empty string to store all info of the calendar and for later printing.
. It puts the header of he table into the string.
. It puts the days of week and dates info into the string.
. To add in events, each event takes 3 rows (time info, description, and dashes) to print. For each 3 rows,
there can be at most 7 events. The events are added per 3 rows. For each 3 rows, the program creates an array of 3 * 7
to store the details. Whenever there exists an event at the position of a day, details of the event will be added to
the corresponding 3 rows (1 column) of the array. The array is then added by rows into the string.
====
E.g. Example of a row of events stored for printing

image::DGCalendarTableRow.png[width = 75%]
====

==== Commands for CalendarView
- `calendar` This prints the calendar table of this 7 days.
- `calendar next` This prints the calendar table of the next 7 days.
- `calendar last` This prints the calendar table of the last 7 days.

=== Check Free Days
CheckFreeDays is a command that allows the program to search for the next 3 days without any
events (except ToDos). +

. When the user enters `check`, starting from the current day, the program
checks all the events whether any is in this day.
. If not, this day will be added into a list.
. Above process will continue until the list has 3 days, which will then be printed.
====
The following logic diagram shows how check free days is implemented.

image::DGCheck.png[width = 100%]
====

=== Checklists
Checklist of each event can be used to remind users of certain items (e.g. bring glasses to concert).
This is implemented by storing an array list of strings in `Event` objects.

Checklist implementation contains 4 operations:

==== add checklist item
`checklist add <event index>/<checklist item>`
This adds an item into a specific event's checklist.

==== view checklist
`checklist view <event index>`
This prints on the screen the checklist of an event.

==== edit checklist item
`checklist edit <event index> <item index>/<new item>`
This edits a specific item in the checklist of an event.

==== delete checklist item
`checklist delete <event index> <item index>`
This deletes an item from the checklist of an event.

=== Clash handling
==== Activity diagram
====
                    +-----------+
                    |  addEvent |
                    |   called  |
                    +-----------+
                          |
                          |
                          v             found
                    +-----------+   matching date   +------------+
          +---------|  Search   | ----------------> |   Compare  |
          |         |   List    |    +--------------|    times   |
          |         +-----------+    |              +------------+
          |                          |            Found     |
     else |                      else|         overlapping  |
          |         +----------------+            times     |
          |         |                                       |
          v         v                                       v
    +-----------------+                         +----------------+
    |      Return     |                         |Exception thrown|
    |       null      |                         | clashing event |
    +-----------------+                         +----------------+
            |                                            |
            |                                            |
            |                                            |
            v                                            v
    +-----------------+                         +----------------+
    |    Add Event    |                         | Alert user of  |
    |     to list     |                         |     clash      |
    +-----------------+                         +----------------+
            |                                            |
            |                                            |
            +----------------|        |------------------+
                             |        |
                             v        v
                            +-----------+
                            | Await new |
                            |  Command  |
                            +-----------+
====

==== How is it implemented
The program is able to *detect clashes when creating new events*. When the user enters the command
to add a new Event entry to the list, the method `EventList.addEvent` is called from the `Command`
class object upon execution.

The `addEvent` method will then call the `EventList.clashEvent` method to check the
existing entries for any clash in schedule. This is done by first searching the list for an event
that has a matching date with the new event, done with a simple loop.

If no such event is found, the method returns a *_null_* value, indicating that there is no schedule clash.
If an event is found with a matching date, the `clashEvent` then calls the `EventList.timeClash` method to check whether
the two events have overlapping time periods. This is done by simple mathematical comparison using `>` and
`<` operators, comparing the times in 24h format as 4 digit integers.

If there is any overlap, the `timeClash` method will return *_true_* as a boolean, indicating there is a schedule clash.
The `clashEvent` method then throws an exception `ClashException`, indicating that there was indeed a schedule
clash between the desired new entry and some pre-existing Event.

The details of the clashing Event are passed back to `Command` object so that it can be used to inform the
user about the clashing event. The user is then required to fix the conflict before continuing,
either by rescheduling or deleting the pre-existing event, or by choosing a different date/time for
the new Event entry.

==== Why it is implemented this way
The process of checking for a clash was implemented as small, simple components so as to ensure scalability,
easier testing, and to reduce dependencies.

The choice to use exception handling to deal with an event clash
was done so that it could be easily re-purposed for any incremental extension that required checking for a
schedule clash. This can be easily done by using `try catch` blocks and catching any `ClashException` thrown
so that suitable action can be taken, and the info for the clashing event can be easily obtained for said
action.

By having the `clashEvent` method return a *_null_* value or a reference to a clashing event in the schedule, the
`clashEvent` method can now be used for any further increments to the code requiring addition of events.

It was thus easy to implement this clash detection as a part of adding recurrent events
(to check for clashes when recurrent events were automatically entered) as well as the
rescheduling function (to check for clashes when the user attempts to reschedule
an existing event, so that he/she does not inadvertently create a new schedule conflict).

Testing is also very simple to implement as it can be done unit by unit or as a whole, due to clash detection
being broken down into multiple simple components, each with a specific purpose.

==== Expected behaviour of functionality
When a user attempts to add an event(recurring or otherwise) and the program detects a clash with an existing event
in the pre-existing list, the following output should be printed: +
#"That event clashes with another in the schedule! Please resolve the conflict and try again!"# +
This is followed by the following line indicating the details of the detected clash: +
#"Clashes with: [E][X] YST Final project review START: Tue, 03 Dec 2019, 15:00 END: Tue, 03 Dec 2019, 18:00#

=== Add recurring events
==== How it is implemented
The program is able to detect recurring events and their periods when creating new events.
When the user enters the command to add a new `Lesson` or `Practice` event with a period (in days) followed,
`createNewEvent` method will call `entryForEvent` to get the period. +
If the new event is not a recurring event, the period value will be assigned to `NON-PERIOD` and then call the
`addEvent` method in the `EventList` class.

After getting the period, the `createNewEvent` method will call the `addRecurringEvent` method in the `EventList` class
to create and store new events in the eventList. +
The calculation of dates are done by Java Calendar, `Calendar.add` function is called to calculate the startDate
and endDate of new events in `Java Date type`. The number of recurring events is depended on the period, since the
maximum date between the first recurring event and the last one is up to `ONE_SEMESTER_DAYS` which is assigned to
16 weeks (112 days) now. +
When creating the `startEventDate` and `endEventDate` of the new event,
`calendar.getTime` is called and the `identifier` in EventDate will be assigned to `DATE_TO_STRING`, so that the
`startDateAndTime` and `endDateAndTime` are in `String type`, which fits the requirement of the `Event` class.

All the events created in the `addRecurringEvent` method will be checked whether having clash with the events in the
current eventList and then added in a temporary event list one by one. If no clash happens, the `tempEventList` will
be added to the current `eventList`.

Given below is an example usage scenario compared to adding non-recurring event. +
Recurring event: `Lesson` or `Practice` <event description> /dd-MM-yyyy HHmm HHmm `/period(in days)` +
Non-recurring event: <event type> <event description> /dd-MM-yyyy HHmm HHmm

==== Sequence diagram
The following sequence diagram shows how the adding recurring event operation works.
====
image::recurringEventSequenceDiagram.png[width = 100%]
====

==== Why it is implemented this way
. Whether the input command has a period is considered at the first, so that the dependency between adding
recurrent events and adding normal events could be reduced.
. The `add(int field, int amount)` method of `Calendar` class is used to add or subtract from the given calendar field
and a specific amount of time, based on the calendar's rules. +
`public abstract void add(int _field_, int _amount_)`
. Since the number of recurrent events with a short period could be large, it is more likely to have clashes with the
current eventList. Hence, before added in the temporary event list, the new event need to be ensured that no clash
happens.
. To keep the format of creating new events, the format process of changing Java Date to String is done in the
`EventDate` class instead of messing the `Event` class to accept both Date and String types as input date and time.

=== Viewing specific dates
==== How is it implemented
The implementation is a simple for loop that runs through the existing task list. If a matching date is detected,
it will return the corresponding task and add it to a temporary list of found tasks. After running through the whole
list, the temporary list will be printed out to display all the tasks of a specific date.

Step 1: When the command "view <date>" is given, the viewEvents() method will be called.

Step 2: A temporary ArrayList is created by the method to be populated.

Step 3: The date string from the input command is passed into the EventDate class to be formatted into the same format as that of
each event and returned as a string.

Step 4: The returned string is compared with each task in the event list to check for any event with a matching date.

Step 5: When an event with a matching date is found, the event is added to the temporary list.

Step 6: After the entire list has been checked, the temporary list is passed into a UI instance

Step 7: The printFoundEvents() method will be called. The said method then prints out the temporary list, displaying the list of events taking place on a specific date.

In the situation when an empty temporary list is passed into the UI for it to print, an exception will occur and the
printFoundEvents() method will catch the exception before printing out a string to inform the user that there are no tasks
taking place on that specific date.

==== Activity Diagram
image::DGViewEventsDiagram.png[]

==== Why is it implemented this way
The matching events are being stored individually into a separate temporary list before being printed out. This is to allow
an easier handling of individual tasks as separate instances in case the user wishes to edit a particular task from the
temporary list.

==== Alternative implementations considered
Storing all the matching events as a single string, passing the string into the printFoundEvents() method to print out. This
implementation is undesirable as it will be difficult to access individual matching events in the case the user wishes to edit
them as mentioned above.

=== Goals List
==== How is it implemented
The goals list is an array list type that stores a list of goals to be achieved by the user for each individual event, particularly
for Lesson and Practice type events. When the user first creates the event, the event is created without a goal list. Only
when the user types in "goal add <event ID>" then a goal list is created for the specified event. The user can then manipulate
the goal list by using "goal edit", "goal delete" or "goal view" commands.

===== Adding a goal
Step 1: When the command "goal add <event ID>" is entered, the goalsManagement() function will be called.

Step 2: The command will be split up into separate strings

=== Reminders

==== How it is implemented
The reminder function filters out the tasks that are due or are happening before 2359 three days after the current date,
and prints them out as a reminder for the users.

After the user enters 'reminder', the Command.execute method calls Command.remindEvents, which in turn calls the
Ui.printReminders function. The Ui.printReminders function calls the EventList.getReminder method, which uses the
EventList.filteredList method to filter out a list of events that are due or are happening before 2359 three
days after the current date. The EventList.filteredList method filters out events from the stored list of events
according to a certain input predicate.

The constructor of the Predicate class takes in two arguments: the reference and the comparator. The reference is the
item that is used for the comparison reference (comp) input, and the comparator is the operator that is used for the
comparison. The comparator should be either one of the three global integer variables: EQUAL, GREATER_THAN or SMALLER_THAN.
The Predicate.check method takes in an input and checks if reference (comp) input is true by calling the appropriate method
in the Predicate class depending on the type of the reference and input.

In the EventList.getReminder method, the reference of the input Predicate object is set to an eventDate object set to
2359 three days after the current date, and the comparator is GREATER_THAN. After that, the EventList.getReminder method
calls the EventList.filteredList method. In the EventList.filteredList method, the system iterates through the list of Events in
`eventArrayList`.The EventDate object stored in the the Event object is passed into the Predicate.check method. If the
EventDate object stored in the the Event object is a date before the reference date, the Predicate.check method returns true
and the Event object is added to the output. After all the elements in EventList.filteredList are parsed and the
EventList.filteredList method terminates, EventList.getReminder method returns a string containing the current date and time,
the date and time at 2359 three days after the current date, and the filtered list of events. This string is printed to
stdout in the Ui.printReminders function.

==== Sequence diagram
The following sequence diagram shows how the reminder functionality works.
====
image::reminderSequenceDiagram.png[width = 100%]
====

==== Why it is implemented this way
The reminder function is split the various components into different methods for easier testing. In this case, Ui.printReminders
prints the output to the user interface, EventList.getReminder is responsible for compiling the output whereas EventList.filteredList
obtains the filtered list of events from `eventArrayList`.

This implementation also implements scalability as the Predicate class and the EventList.filteredList method can be reused for other
functionalities.


== Documentation


== Testing


== Dev Ops


[appendix]
== Product Scope
=== Target User Profile
MisterMusik is a scheduler program created for serious music students pursuing a professional music career as a western classical music performer.
The program is designed to automate and streamline most of the process in scheduling and organisation of materials, allowing the students to focus more on the important aspects of their education.


[appendix]
== User Stories
. As a busy music student with multiple classes, I want to be able to track my practice sessions so that I won’t miss any trainings.
. As a music student with a heavy workload, I want to be able to track my upcoming recitals and their details so I can prioritize which pieces/what techniques to practice and focus on.
. As a music student with a tendency to procrastinate in things I need to do, I want to be constantly reminded of my examination dates so i do not wait till the last minute to prepare for them.
. As a student who wants to maximize my efficiency in practice sessions (performer), I want to be able to rate and comment on the efficiency of my practice sessions and be able to review them to make sure that I learn and improve faster.
. As a student who wants to categorize what I learn in classes, I want to be able to take notes and organize them into different categories, so that I can easily review it anytime.
. As a student who wishes to be aware of his upcoming events, I wish to be able to view my schedule within a selected number of weeks so that I can plan for it.


[appendix]
== Use cases

=== Entering a practice schedule into the system
. User enters a command to add a practice followed by a date, and the details of the intended practice.
. System prompts user about whether or not he wishes to make this a recurring practice (e.g every Tuesday).
. User responds to the prompt accordingly.
. System adds practice session to a stored list and saves it to a file on the user’s hard drive.

=== Entering the details of a recital into the system
. User choose to enter a recital.
. System requires details of the recital.
. User enters date, time, venue, the pieces to be performed, and a description if needed.
. System adds recital to a stored list and saves it to a file on the user’s hard drive.

Extension 3.1: System detects there is a clash with a concert/practice session at step 3.
3.1.1.  System generates warnings and ask user to delete the corresponding entry and forgo that event.
3.1.2.  User responds to the warning, deleting or rescheduling one of the events in a clash if necessary.
3.1.3. System updates the stored list and saves it to the file on the user’s hard disk.

Extension 3.2: System detects a clash with another recital or an examination at step 3.
3.2.1.  System generates warnings and ask user to reschedule and re-enter one of the events that clash.
3.2.2.  User responds to the warning, rescheduling and re-entering one of the events in a clash.
3.2.3. System updates the stored list and saves it to the file on the user’s hard disk.
Use case ends

=== Making notes
. User chooses to enter a command to start a note-taking/viewing session
. System shows the user a list of categories (directories) of notes that have been made previously and prompts the user to enter one or create a new file.
. User makes a choice to enter a category directory or create a new one.
. System shows the user a list of files containing notes, each file is named with the corresponding date, and a description of the file decided by the user. System also prompts the user if he wants to create a new file or enter an existing one.
. User selects a file to enter or chooses to create a new file.
. System opens the file for viewing and editing. The user can choose to make changes to the notes using commands: delete, add and move to delete, add or move notes around the file accordingly.

Extension 3.1: System detects there is no category file that user commands to edit on
3.1.1. System generates warnings and ask the user whether or not he wishes to add a new category and take notes in
3.1.2. User responds to the warning, and choose to add a new category
3.1.3. System adds and opens a new category file with the name given by user

=== Viewing upcoming events
. User enters command `list` followed by an integer N representing the number of weeks in advance he would like to view his schedule.
. System responds by showing the user a list of events in the next N weeks.
. User may enter a command to remove specific tasks from the list, to have a cleaner viewing experience.

Extension 3.1: System can remove types of events from list at user’s command
3.1.1. User can enter commands `remove examinations` for example, to remove the examinations from the display.
3.1.2. System responds accordingly, removing the type of event from the list and altering the list of events displayed.

Extension: 3.2. System can allow the user to only view a specific type of event.
3.2.1. User can also enter commands `show examinations` for example, to only show examinations in the list of events.
3.2.2. System will respond accordingly, displaying only type of event that the user specified.

Extension: 3.3. System can allow the user to only view events on a specific date.
3.3.1. User can enter the command "view <dd-MM-yyyy>"" to view all events on that specific date.
3.3.2. System will display the events, and the user can edit the events accordingly.

=== Entering the examination details
. User enters command `examination`, together with a description of the examination, along with the date, time, venue and any other notes in a given format.
. The system adds the examination to the list of events.

Extension 1.1: System detects a clash with the examination date entered and another event.
1.1.1. System will prompt the user to reschedule the event of lower priority. (examinations and recitals are of highest priority, followed by concerts and then practices). If the clash is with an event of the same priority, the user is prompted to choose which one to reschedule(simple y/n response).
1.1.2. User reschedules the specified event by entering a date and time. The user is also able to delete an event with the delete command to free up the schedule if he wishes to do so.
1.1.3. System once again checks for clashes and repeats the process of rescheduling if necessary.

=== Rate and comment on the efficiency of practice sessions
. User enters a command to rate a practice session
. System brings up a list of practice sessions that the user has already completed
. User selects a practice session
. System displays the details of the selected practice session and prompts the user to select an efficiency rating along with any additional notes
. User rates the efficiency of the practice session and takes down any notes or feedback from their instructor
. System saves the entry onto the hard disk

=== Edit descriptions of any existing event
. User enters a command to edit the description of an event
. System edits corresponding description and prompts user of success

Extension 1: System detects a clash of incorrect format entered by the user.
1.1. System will prompt the user that the entered format was incorrect.

Extensions 4.1: Selected practice session has already been rated.
4.1.1. If the selected practice session has already been rated, the system notifies the user and allows them to edit.
4.1.2. The user edits the rating and notes of the practice session accordingly
4.1.3. System saves the changes onto the hard disk

Extensions 5.1: User inputs an invalid rating.
5.1.1. System displays an error message to inform the user of the correct rating format until a valid input is detected.

=== Viewing all events in the coming 7 days.
. User enters a command to view all events in the next 7 days.
. System shows all events in the next 7 days in a calendar table.

[appendix]
== Non-functional requirements
. System should work on windows and linux.
. System response within 1 second.
. Usable by non tech-savvy individuals.
. Clear user prompts
. Visually pleasing display


[appendix]
== Instructions for Manual Testing

=== Launch and Shutdown
. Initial Launch
.. Open Duke.java in src.
.. Run the file +
   Expected: The Welcome Message is printed in stdout and the system requests for an input.

. Shutdown
.. Key in `bye` as input. +
   Expected: The Goodbye Message ('Bye. Hope to see you again soon!') is printed in stdout and the process exits.

=== Obtain the list of items currently in stored in the system
. Key in `list` as input +
  Expected: A list of items is printed in stdout.


=== Add a Task
. Add Todo +
   Key in `todo tdtask /01-01-2011 0100` +
   Expected: Output should be +
   Got it. I've added this task: +
   [x][T] tdtask  BY: Sat, 01 Jan 2011, 01:00 +
   Now you have <previous number of items + 1> items in the list.

. Add Exam +
   Key in `exam Music Rudiments /08-08-2018 0800 0900` +
   Expected: Output should be +
   Got it. I've added this task: +
   [x][E] Music Rudiments  START: Wed, 08 Aug 2018, 08:00 END: Wed, 08 Aug 2018, 09:00 +
   Now you have <previous number of items + 1> tasks in the list.

. Add Practice session +
   Key in `practice morningprac /07-08-2018 0800 0900` +
   Expected: Output should be +
   Got it. I've added this event: +
   [x][P] morningprac  START: Tue, 07 Aug 2018, 08:00 END: Tue, 07 Aug 2018, 09:00 +
   Now you have <previous number of items + 1> tasks in the list.

. Add Concert +
   Key in `concert Noon Concert /06-06-2016 1200 1400` +
   Expected: Output should be +
   Got it. I've added this task: +
   [x][C] Noon Concert  START: Mon, 06 Jun 2016, 12:00 END: Mon, 06 Jun 2016, 14:00 +
   Now you have <previous number of items + 1> tasks in the list.

. Add Recital +
   Key in `recital Evening Recital /07-07-2017 1900 2100` +
   Expected: Output should be +
   Got it. I've added this task: +
   [x][R] Evening Recital  START: Fri, 07 Jul 2017, 19:00 END: Fri, 07 Jul 2017, 21:00 +
   Now you have <previous number of items + 1> tasks in the list.

. Add Lesson +
   Key in `lesson Class /09-09-2019 0900 0100` +
   Expected: Output should be +
   Got it. I’ve added this task: +
   [x][L] Class  START: Mon, 09 Sep 2019, 09:00 END: Mon, 09 Sep 2019, 01:00 +
   Now you have <previous number of items + 1> tasks in the list.

=== Set a Task as done
Key in `done 1` +
Expected: Prints a message that the first task on the list has been marked as done.

=== Find tasks that contains a certain keyword or key phrase
Key in `find <key>`, where `<key>` is the keyword or key phrase +
Expected: Prints a list of tasks that contains the `<key>`.

=== Get reminder
Key in `reminder` +
Expected: Prints a list of tasks to be completed in the next three days.

=== View all tasks in a certain day
Key in view `<date>`, where `<date>` has the format dd/MM/yyyy. +
Expected: Prints a list of tasks that occurs on the given `<date>`.

=== Edit description of an event
Key in `<edit> <event index>/<new description>`.+
Expected: Prints the success of editing event of index `<event index>`.

=== Reschedule an event
Key in `<reschedule> <event index> <new date> <new start time> <new end time>`,
where `<new date> <new start time> <new end time>` has the format dd-MM-yyyy HH:mm HH:mm. +
Expected: Prints the success of rescheduling event of index `<event index>`.

=== Check the next 3 free days
Key in `check`. +
Expected: Prints the next 3 days without any events.

=== View the calendar table of the next 7 days.
Key in `calendar`.+
Expected: Prints the calendar table containing all events of the next 7 days,
where the first column of the table is the current day.

=== Contact management
. Add contact to an event in the list +
Key in `contact add <event index> /<name>, <email>, <phone number>` +
Expected: Prints the success of adding the contact.

. Delete contact +
Key in `contact delete <event index> <contact index> /` +
Expected: Prints the success of deleting the contact.

. View contact +
Key in `contact view <event index> /` +
Expected: Prints the contacts information in the event.

. Edit contact +
Key in `contact edit <event index> <contact index> <edit type> /<new contact information>` +
Expected: Prints the success of editing the contact.

[appendix]
== Instructions for Manual Testing
=== Launch and Shutdown
